<!doctype html>
<html lang="nl">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Bridge Builder (brug + stroom)</title>

<style>
  body{
    margin:0;
    font-family:system-ui, sans-serif;
    background:#0b1220;
    color:#e7eefc;
    display:flex;
    justify-content:center;
    padding:28px;
  }
  .app{width:min(1000px, 100%);}
  h1{margin:0 0 8px}
  p{margin:0 0 16px;color:#a9b7d3}

  .stage{
    background:#081124;
    border-radius:16px;
    padding:14px;
    border:1px solid rgba(255,255,255,.08);
  }
  canvas{
    width:100%;
    height:auto;
    border-radius:12px;
    background:#0e1b33;
    border:1px solid rgba(255,255,255,.10);
    display:block;
  }

  .controls{
    margin-top:14px;
    display:grid;
    grid-template-columns:repeat(3,1fr);
    gap:10px;
  }
  button{
    padding:12px;
    border-radius:12px;
    border:none;
    font-weight:800;
    cursor:pointer;
  }
  .primary{background:#60a5fa;color:#081124}
  .secondary{background:#1e293b;color:#e7eefc}
  .danger{background:#7f1d1d;color:#e7eefc}

  .msg{
    margin-top:12px;
    padding:12px;
    background:#081124;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.10);
    min-height:52px;
    color:#a9b7d3;
    line-height:1.35;
  }

  .meta{
    margin-top:10px;
    color:#a9b7d3;
    font-size:13px;
    display:flex;
    gap:10px;
    flex-wrap:wrap;
  }
  .pill{
    display:inline-block;
    padding:2px 10px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.06);
  }

  @media (max-width:820px){
    .controls{grid-template-columns:1fr}
  }
</style>
</head>

<body>
<div class="app">
  <h1>Bridge Builder</h1>
  <p>Bouw de brug. Test met het autootje. Leg daarna kabel zodat de lampjes echt aan gaan.</p>

  <div class="stage">
    <canvas id="cv" width="900" height="460"></canvas>
  </div>

  <div class="meta">
    <span class="pill" id="phasePill">Fase: Brug bouwen</span>
    <span class="pill" id="bridgePill">Brug: â€”</span>
    <span class="pill" id="powerPill">Stroom: â€”</span>
  </div>

  <div class="controls">
    <button class="secondary" id="deckBtn">Tool: Dek âœ“</button>
    <button class="secondary" id="pillarBtn">Tool: Pilaar</button>
    <button class="secondary" id="wireBtn">Tool: Kabel</button>

    <button class="primary" id="testBtn">Test (auto rijdt)</button>
    <button class="secondary" id="resetBtn">Reset</button>
    <button class="danger" id="clearBtn">Alles wissen</button>
  </div>

  <div class="msg" id="msg">Klik op de bruglijn om dekdelen te plaatsen. (Shift+klik = weghalen)</div>
</div>

<script>
(() => {
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");

  const msg = document.getElementById("msg");
  const deckBtn = document.getElementById("deckBtn");
  const pillarBtn = document.getElementById("pillarBtn");
  const wireBtn = document.getElementById("wireBtn");

  const testBtn = document.getElementById("testBtn");
  const resetBtn = document.getElementById("resetBtn");
  const clearBtn = document.getElementById("clearBtn");

  const phasePill = document.getElementById("phasePill");
  const bridgePill = document.getElementById("bridgePill");
  const powerPill = document.getElementById("powerPill");

  const W = cv.width;
  const H = cv.height;

  // Layout
  const slots = 10;
  const bridgeY = 200;
  const leftX = 110;
  const rightX = W - 110;
  const segW = (rightX - leftX) / slots;

  // River zone (visual)
  const riverX1 = leftX + segW * 3;
  const riverX2 = leftX + segW * 7;

  // Power objects
  const batterySlot = 1;            // BAT sits on slot 2 (index 1)
  const lampSlots = [2, 5, 8];      // 3 lamps

  // State
  let tool = "deck";               // deck | pillar | wire
  let phase = "build";             // build | power
  let bridgeOk = false;
  let powerOk = false;

  const deck = new Set();          // deck pieces (0..9)
  const pillars = new Set();       // pillars (0..9)
  const wire = new Set();          // cable segments (0..9)

  // Car
  const car = {
    x: 0,
    y: bridgeY - 28,
    w: 56,
    h: 20,
    driving: false,
    state: "idle"
  };

  function setMessage(t){ msg.textContent = t; }

  function slotFromX(x){
    return Math.floor((x - leftX) / segW);
  }
  function clampSlot(s){ return Math.max(0, Math.min(slots-1, s)); }

  function resetCarToFirstDeck(){
    let s = null;
    for (let i=0;i<slots;i++){
      if (deck.has(i)){ s = i; break; }
    }
    if (s === null){
      car.x = leftX - car.w - 10;
      car.y = bridgeY - 28;
      car.driving = false;
      car.state = "idle";
      return;
    }
    const x1 = leftX + s * segW;
    car.x = x1 + 6;
    car.y = bridgeY - 28;
    car.driving = false;
    car.state = "idle";
  }

  function carCenterX(){ return car.x + car.w/2; }

  function hasDeckUnderCar(){
    const cx = carCenterX();
    if (cx >= rightX) return true;
    if (cx <= leftX) return true;
    const s = slotFromX(cx);
    if (s < 0 || s >= slots) return false;
    return deck.has(s);
  }

  function bridgeComplete(){
    for (let i=0;i<slots;i++){
      if (!deck.has(i)) return false;
    }
    return true;
  }

  // Power check: BFS over adjacency along slots with wire (and deck)
  function isPowered(){
    if (!bridgeOk) return false; // only after bridge test succeeds
    // battery slot must have deck
    if (!deck.has(batterySlot)) return false;

    const powered = new Set([batterySlot]);
    const q = [batterySlot];

    const passable = (s) => deck.has(s) && (wire.has(s) || s === batterySlot);

    while (q.length){
      const s = q.shift();
      for (const ns of [s-1, s+1]){
        if (ns < 0 || ns >= slots) continue;
        if (!powered.has(ns) && passable(s) && passable(ns)){
          powered.add(ns);
          q.push(ns);
        }
      }
    }

    // all lamp slots must be reached
    return lampSlots.every(ls => powered.has(ls));
  }

  function updatePills(){
    phasePill.textContent = `Fase: ${phase === "build" ? "Brug bouwen" : "Stroom leggen"}`;
    bridgePill.textContent = `Brug: ${bridgeOk ? "âœ…" : "â€”"}`;
    powerPill.textContent = `Stroom: ${powerOk ? "âœ…" : "â€”"}`;
  }

  function setTool(newTool){
    tool = newTool;
    deckBtn.textContent = `Tool: Dek${tool==="deck"?" âœ“":""}`;
    pillarBtn.textContent = `Tool: Pilaar${tool==="pillar"?" âœ“":""}`;
    wireBtn.textContent = `Tool: Kabel${tool==="wire"?" âœ“":""}`;
  }

  function setPhase(newPhase){
    phase = newPhase;
    updatePills();
  }

  // Drawing
  function draw(){
    ctx.clearRect(0,0,W,H);

    // bg
    ctx.fillStyle = "#0e1b33";
    ctx.fillRect(0,0,W,H);

    // ground
    ctx.fillStyle = "rgba(34,197,94,.10)";
    ctx.fillRect(0, bridgeY+95, W, H-(bridgeY+95));

    // river
    ctx.fillStyle = "rgba(37,99,235,.30)";
    ctx.fillRect(riverX1, bridgeY+35, riverX2-riverX1, 220);
    ctx.fillStyle = "rgba(191,219,254,.14)";
    for (let i=0;i<8;i++){
      ctx.fillRect(riverX1+16, bridgeY+55+i*24, (riverX2-riverX1)-32, 6);
    }

    // bridge baseline
    ctx.strokeStyle = "rgba(148,163,184,.60)";
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(leftX, bridgeY);
    ctx.lineTo(rightX, bridgeY);
    ctx.stroke();
    ctx.lineWidth = 1;

    // slot labels
    ctx.fillStyle = "rgba(169,183,211,.40)";
    ctx.font = "12px system-ui";
    for (let i=0;i<slots;i++){
      const x = leftX + i*segW + segW/2;
      ctx.fillText(String(i+1), x-3, bridgeY-24);
    }

    // pillars
    for(const s of pillars){
      const x = leftX + s*segW + segW/2;
      ctx.fillStyle = "rgba(203,213,225,.95)";
      ctx.fillRect(x-10, bridgeY+6, 20, 120);
      ctx.fillStyle = "rgba(15,23,42,.25)";
      ctx.fillRect(x-14, bridgeY+126, 28, 10);
    }

    // deck
    for(const s of deck){
      const x = leftX + s*segW;
      ctx.fillStyle = "rgba(229,231,235,.95)";
      ctx.fillRect(x+4, bridgeY-16, segW-8, 32);

      ctx.fillStyle = "rgba(15,23,42,.10)";
      ctx.fillRect(x+10, bridgeY-8, segW-20, 2);
      ctx.fillRect(x+10, bridgeY+2, segW-20, 2);
      ctx.fillRect(x+10, bridgeY+12, segW-20, 2);
    }

    // wire (only visible on deck)
    for(const s of wire){
      if (!deck.has(s)) continue;
      const x = leftX + s*segW;
      ctx.strokeStyle = "rgba(96,165,250,.95)";
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(x+14, bridgeY-2);
      ctx.lineTo(x+segW-14, bridgeY-2);
      ctx.stroke();
      ctx.lineWidth = 1;
    }

    // battery
    {
      const x = leftX + batterySlot*segW + 14;
      const y = bridgeY - 70;
      ctx.fillStyle = "rgba(245,158,11,.22)";
      ctx.fillRect(x, y, 54, 32);
      ctx.fillStyle = "rgba(245,158,11,.92)";
      ctx.font = "bold 12px system-ui";
      ctx.fillText("BAT", x+14, y+21);
    }

    // lamps
    for (const s of lampSlots){
      const x = leftX + s*segW + segW/2;
      const y = bridgeY - 52;

      // pole
      ctx.fillStyle = "rgba(148,163,184,.85)";
      ctx.fillRect(x-2, bridgeY-18, 4, 24);

      const lit = powerOk;
      if (lit){
        ctx.fillStyle = "rgba(250,204,21,.95)";
        ctx.beginPath(); ctx.arc(x, y, 9, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "rgba(250,204,21,.18)";
        ctx.beginPath(); ctx.arc(x, y, 22, 0, Math.PI*2); ctx.fill();
      } else {
        ctx.fillStyle = "rgba(148,163,184,.90)";
        ctx.beginPath(); ctx.arc(x, y, 9, 0, Math.PI*2); ctx.fill();
      }
    }

    drawCar();

    // phase hint
    ctx.fillStyle = "rgba(169,183,211,.85)";
    ctx.font = "12px system-ui";
    ctx.fillText(
      phase === "build"
        ? "Fase 1: Bouw de brug (dek/pilaren) en test met de auto."
        : "Fase 2: Leg kabel (blauw) op dek-segmenten. Verbind BAT met alle lampen.",
      14, H-16
    );
  }

  function drawCar(){
    const x = car.x;
    const y = car.y;

    // shadow
    ctx.fillStyle = "rgba(0,0,0,.35)";
    ctx.beginPath();
    ctx.ellipse(x+28, y+38, 24, 7, 0, 0, Math.PI*2);
    ctx.fill();

    // body
    ctx.fillStyle = "rgba(96,165,250,.92)";
    ctx.fillRect(x, y+12, 56, 18);

    // cabin
    ctx.fillStyle = "rgba(226,232,240,.88)";
    ctx.fillRect(x+16, y+4, 26, 12);

    // window
    ctx.fillStyle = "rgba(15,23,42,.55)";
    ctx.fillRect(x+20, y+6, 18, 8);

    // wheels
    ctx.fillStyle = "rgba(2,6,23,.95)";
    ctx.beginPath(); ctx.arc(x+14, y+32, 5.5, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+44, y+32, 5.5, 0, Math.PI*2); ctx.fill();
  }

  // Animation
  let raf = null;
  function stopAnim(){
    if (raf) cancelAnimationFrame(raf);
    raf = null;
  }

  function animate(){
    if (!car.driving) return;

    car.x += 3.0;

    if (!hasDeckUnderCar()){
      car.driving = false;
      car.state = "falling";
      bridgeOk = false;
      powerOk = false;
      setPhase("build");
      setMessage("ðŸ’¥ Gat in het dek. Vul alle 10 segmenten met dekdelen en test opnieuw.");
      updatePills();
      draw();
      return;
    }

    if (carCenterX() >= rightX){
      car.driving = false;
      car.state = "success";
      bridgeOk = true;

      // After bridge success: move to power phase
      setPhase("power");
      setTool("wire");

      // power not auto-on: user must place wire
      powerOk = isPowered();

      setMessage("âœ… Brug werkt! Nu: leg kabel (tool Kabel) zodat alle lampen aan gaan. (Shift+klik verwijdert kabel)");
      updatePills();
      draw();
      return;
    }

    draw();
    raf = requestAnimationFrame(animate);
  }

  // Input
  cv.addEventListener("click", (e) => {
    if (car.driving) return;

    const rect = cv.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (W / rect.width);
    const my = (e.clientY - rect.top) * (H / rect.height);

    // Only allow interaction near the bridge band
    if (Math.abs(my - bridgeY) > 95) return;

    const rawS = slotFromX(mx);
    if (rawS < 0 || rawS >= slots) return;
    const s = clampSlot(rawS);

    const remove = e.shiftKey;

    if (phase === "build"){
      powerOk = false; // any change invalidates power
      if (tool === "deck"){
        if (remove) deck.delete(s); else deck.add(s);
        setMessage("Dek aangepast. Doel: alle 10 segmenten vullen. Test daarna met de auto.");
      } else if (tool === "pillar"){
        if (remove) pillars.delete(s); else pillars.add(s);
        setMessage("Pilaar aangepast. (Optioneel, voor 'bruggevoel'.)");
      } else if (tool === "wire"){
        setMessage("Kabel leg je pas na een geslaagde brugtest. Eerst bouwen + testen.");
      }

      // editing bridge resets success
      bridgeOk = false;
      resetCarToFirstDeck();
      updatePills();
      draw();
      return;
    }

    // phase === power
    if (!bridgeOk){
      setPhase("build");
      setMessage("Eerst brug testen. Daarna kun je stroom leggen.");
      updatePills();
      draw();
      return;
    }

    if (tool !== "wire"){
      setMessage("Je zit in â€˜stroomâ€™-fase. Kies tool Kabel om de lampen aan te sluiten.");
      return;
    }

    // Cable can only be placed on deck
    if (!deck.has(s)){
      setMessage("Kabel kan alleen op een dekdeel. Plaats eerst dek (in bouwfase) en test de brug.");
      return;
    }

    if (remove) wire.delete(s); else wire.add(s);

    powerOk = isPowered();
    updatePills();

    if (powerOk){
      setMessage("ðŸ’¡ Gelukt! Alle lampen hebben stroom. (Je hebt BAT verbonden met alle lampen.)");
    } else {
      setMessage("Leg kabel (blauw) vanaf BAT naar alle lampen. Tip: maak Ã©Ã©n doorlopende kabelroute over de brug.");
    }
    draw();
  });

  // Buttons
  deckBtn.onclick = () => {
    setTool("deck");
    setMessage("Tool: Dek. Klik op de bruglijn om dekdelen te plaatsen. (Shift+klik = verwijderen)");
  };

  pillarBtn.onclick = () => {
    setTool("pillar");
    setMessage("Tool: Pilaar. Klik op de bruglijn om pilaren te plaatsen. (Shift+klik = verwijderen)");
  };

  wireBtn.onclick = () => {
    setTool("wire");
    if (phase === "build"){
      setMessage("Kabel leg je pas na een geslaagde brugtest. Eerst bouwen + testen.");
    } else {
      setMessage("Tool: Kabel. Klik op dekdelen om kabel te leggen. (Shift+klik = verwijderen)");
    }
  };

  testBtn.onclick = () => {
    if (car.driving) return;

    // Reset success states on new test
    powerOk = false;
    bridgeOk = false;
    updatePills();

    if (!bridgeComplete()){
      setPhase("build");
      setMessage("Nog niet testbaar: je brug is niet compleet. Vul alle 10 segmenten met dekdelen.");
      draw();
      return;
    }

    setPhase("build");
    resetCarToFirstDeck();

    // Ensure car starts on bridge
    if (car.x < leftX) car.x = leftX + 6;

    car.driving = true;
    car.state = "driving";
    setMessage("ðŸš— Test looptâ€¦");
    stopAnim();
    draw();
    raf = requestAnimationFrame(animate);
  };

  resetBtn.onclick = () => {
    stopAnim();
    // keep built elements, but reset phases and results
    bridgeOk = false;
    powerOk = false;
    setPhase("build");
    resetCarToFirstDeck();
    setMessage("Reset. Pas je brug aan en test opnieuw.");
    updatePills();
    draw();
  };

  clearBtn.onclick = () => {
    stopAnim();
    deck.clear();
    pillars.clear();
    wire.clear();
    bridgeOk = false;
    powerOk = false;
    setPhase("build");
    resetCarToFirstDeck();
    setMessage("Alles gewist. Bouw opnieuw (dekdelen op 1 t/m 10).");
    updatePills();
    draw();
  };

  // Init
  setTool("deck");
  setPhase("build");
  resetCarToFirstDeck();
  setMessage("Klik op de bruglijn om dekdelen te plaatsen. Vul 1 t/m 10. Test daarna met de auto.");
  updatePills();
  draw();
})();
</script>
</body>
</html>
